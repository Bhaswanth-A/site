I"J+<h2 id="aim">Aim</h2>
<p>To Build a cheap ADC for Raspberry Pi.
<!--more--></p>

<h2 id="details">Details</h2>
<p>Raspberry Pi does not have an in-built ADC and but it needs one for sure. It is tough finding MCP3008 or ADS series ICs which are costlier and easier to use (they have an SPI or I2C integrated). This is how he found his new way to solve out the problem, which many of you may face while dealing with Raspberry Pi.</p>

<h2 id="hardware-used">Hardware Used</h2>
<p>ADC0808 or ADC0809 (8 bit analog to parallel digital converter )
CD4051 (3 to 8 multiplexer/demultiplexer)
555 timer ICs.
Resistor and Capacitors for clock.
Pull down resistors of higher value.</p>

<h2 id="technical-details">Technical details</h2>
<p>Here the ADC0809 IC is kept at a stable input of 0, 0, 0 to pins a, b, c to read ADC pin no 0 (it can be kept altering also and controlled by processor as per the need).The ADC needs a clock to read the Analog input pin and then store in a parallel out register. Here, in the project, a 1Khz clock from a 555 timer IC has been used.
NOTE : Clock frequency can not be increased over 6 MHz as this hampers the raspberry pi digital pins.</p>

<p>You can find out values of resistors and capacitors used for clock, from online 555 timer calculator, he used a tutorial for his <a href="http://www.eng.buffalo.edu/shaw/student/m1_safety/01_home/ksb/ksb3/old_ksb3_timer.htm">clock.</a></p>

<p>The parallel data out from ADC0809 is then read by the processor bit by bit starting from the LSB to MSB and a code verifies the value of Analog read and returns an integer between 0 to 255(we used an 8 bit ADC).
Essentially on purpose the code has been reduced to a library for C++ language.</p>

<h3 id="to-make-a-library">To make a library:</h3>

<p>store the source file under <code class="language-plaintext highlighter-rouge">~/analogread/src/analogread.cpp</code>
store the header file under <code class="language-plaintext highlighter-rouge">~/analogread/inc/analogread.h</code>
also use
<code class="language-plaintext highlighter-rouge">mkdir ~/analogread/obj ~/analogread/lib</code></p>

<p>then compile your obj code
<code class="language-plaintext highlighter-rouge">g++ ~/analogread/src/analogread.cpp -o ~/analogread/obj/analogread.o -lwiringPi</code></p>

<p>then make a static lib as
<code class="language-plaintext highlighter-rouge">ar rcs ~/analogread/lib/analogread.a ~/analogread/obj/analogread.o</code></p>

<p>now your lib is ready
it has 2 methods for the object type analogread.</p>

<ul>
  <li>void setabcr(int a,int b,int c,int r)
as in picture shown a,b,c,r are the I/O pins that are connected.</li>
  <li>read(void)
returns an integer corresponding to the reading.</li>
</ul>

<h3 id="attachments">Attachments</h3>

<p>1 <a href="https://technopediabphc.files.wordpress.com/2015/07/header.docx">Header</a>
2 <a href="https://technopediabphc.files.wordpress.com/2015/07/source.docx">Source</a></p>

<div class="swiper swiper-demo">
  <div class="swiper__wrapper">
    <div class="swiper__slide"><img class="image image" src="/site/assets/images/blog/DIY-ADC-Raspi/pinout.png" /></div>
    <div class="swiper__slide"><img class="image image" src="/site/assets/images/blog/DIY-ADC-Raspi/PCB.png" /></div>
    <div class="swiper__slide"><img class="image image" src="/site/assets/images/blog/DIY-ADC-Raspi/exp.png" /></div>
    <div class="swiper__slide"><img class="image image" src="/site/assets/images/blog/DIY-ADC-Raspi/ADC.png" /></div>
  </div>
  <div class="swiper__button swiper__button--prev fas fa-chevron-left"></div>
  <div class="swiper__button swiper__button--next fas fa-chevron-right"></div>
</div>

<style>
.swiper-demo {
  height: auto;
}
</style>

<script>(function() {
  var SOURCES = window.TEXT_VARIABLES.sources;
  window.Lazyload.js(SOURCES.jquery, function() {
    function swiper(options) {
      var $window = $(window), $root = this, $swiperWrapper, $swiperSlides, $swiperButtonPrev, $swiperButtonNext,
        initialSlide, animation, onChange, onChangeEnd,
        rootWidth, count, preIndex, curIndex, translateX, CRITICAL_ANGLE = Math.PI / 3;

      function setOptions(options) {
        var _options = options || {};
        initialSlide = _options.initialSlide || 0;
        animation = _options.animation === undefined && true;
        onChange = onChange || _options.onChange;
        onChangeEnd = onChangeEnd || _options.onChangeEnd;
      }

      function init() {
        $swiperWrapper = $root.find('.swiper__wrapper');
        $swiperSlides = $root.find('.swiper__slide');
        $swiperButtonPrev = $root.find('.swiper__button--prev');
        $swiperButtonNext = $root.find('.swiper__button--next');
        animation && $swiperWrapper.addClass('swiper__wrapper--animation');
        calc(true);
      }

      function preCalc() {
        rootWidth = $root.width();
        count = $swiperWrapper.children('.swiper__slide').length;
        if (count < 2) {
          $swiperButtonPrev.addClass('d-none');
          $swiperButtonNext.addClass('d-none');
        }
        curIndex = initialSlide || 0;
        translateX = getTranslateXFromCurIndex();
      }

      var calc = (function() {
        var preAnimation, $swiperSlide, $preSwiperSlide;
        return function (needPreCalc, params) {
          needPreCalc && preCalc();
          var _animation = (params && params.animation !== undefined) ? params.animation : animation;
          if (preAnimation === undefined || preAnimation !== _animation) {
            preAnimation = _animation ? $swiperWrapper.addClass('swiper__wrapper--animation') :
              $swiperWrapper.removeClass('swiper__wrapper--animation');
          }
          if (preIndex !== curIndex) {
            ($preSwiperSlide = $swiperSlides.eq(preIndex)).removeClass('active');
            ($swiperSlide = $swiperSlides.eq(curIndex)).addClass('active');
            onChange && onChange(curIndex, $swiperSlides.eq(curIndex), $swiperSlide, $preSwiperSlide);
            if (onChangeEnd) {
              if (_animation) {
                setTimeout(function() {
                  onChangeEnd(curIndex, $swiperSlides.eq(curIndex), $swiperSlide, $preSwiperSlide);
                }, 400);
              } else {
                onChangeEnd(curIndex, $swiperSlides.eq(curIndex), $swiperSlide, $preSwiperSlide);
              }
            }
            preIndex = curIndex;
          }
          $swiperWrapper.css('transform', 'translate(' + translateX + 'px, 0)');
          if (count > 1) {
            if (curIndex <= 0) {
              $swiperButtonPrev.addClass('disabled');
            } else {
              $swiperButtonPrev.removeClass('disabled');
            }
            if (curIndex >= count - 1) {
              $swiperButtonNext.addClass('disabled');
            } else {
              $swiperButtonNext.removeClass('disabled');
            }
          }
        };
      })();

      function getTranslateXFromCurIndex() {
        return curIndex <= 0 ? 0 : - rootWidth * curIndex;
      }

      function moveToIndex(index ,params) {
        preIndex = curIndex;
        curIndex = index;
        translateX = getTranslateXFromCurIndex();
        calc(false, params);
      }

      function move(type) {
        var nextIndex = curIndex, unstableTranslateX;
        if (type === 'prev') {
          nextIndex > 0 && nextIndex--;
        } else if (type === 'next') {
          nextIndex < count - 1 && nextIndex++;
        }
        if (type === 'cur') {
          moveToIndex(curIndex, { animation: true });
          return;
        }
        unstableTranslateX = translateX % rootWidth !== 0;
        if (nextIndex !== curIndex || unstableTranslateX) {
          unstableTranslateX ? moveToIndex(nextIndex, { animation: true }) : moveToIndex(nextIndex);
        }
      }

      setOptions(options);
      init();
      preIndex = curIndex;

      $swiperButtonPrev.on('click', function(e) {
        e.stopPropagation();
        move('prev');
      });
      $swiperButtonNext.on('click', function(e) {
        e.stopPropagation();
        move('next');
      });
      $window.on('resize', function() {
        calc(true, { animation: false });
      });

      (function() {
        var pageX, pageY, velocityX, preTranslateX = translateX, timeStamp, touching;
        function handleTouchstart(e) {
          var point = e.touches ? e.touches[0] : e;
          pageX = point.pageX;
          pageY = point.pageY;
          velocityX = 0;
          preTranslateX = translateX;
        }
        function handleTouchmove(e) {
          if (e.touches && e.touches.length > 1) {
            return;
          }
          var point = e.touches ? e.touches[0] : e;
          var deltaX = point.pageX - pageX;
          var deltaY = point.pageY - pageY;
          velocityX = deltaX / (e.timeStamp - timeStamp);
          timeStamp = e.timeStamp;
          if (e.cancelable && Math.abs(Math.atan(deltaY / deltaX)) < CRITICAL_ANGLE) {
            touching = true;
            translateX += deltaX;
            calc(false, { animation: false });
          }
          pageX = point.pageX;
          pageY = point.pageY;
        }
        function handleTouchend() {
          touching = false;
          var deltaX = translateX - preTranslateX;
          var distance = deltaX + velocityX * rootWidth;
          if (Math.abs(distance) > rootWidth / 2) {
            distance > 0 ? move('prev') : move('next');
          } else {
            move('cur');
          }
        }
        $swiperWrapper.on('touchstart', handleTouchstart);
        $swiperWrapper.on('touchmove', handleTouchmove);
        $swiperWrapper.on('touchend', handleTouchend);
        $swiperWrapper.on('touchcancel', handleTouchend);

        (function() {
          var pressing = false, moved = false;
          $swiperWrapper.on('mousedown', function(e) {
            pressing = true; handleTouchstart(e);
          });
          $swiperWrapper.on('mousemove', function(e) {
            pressing && (e.preventDefault(), moved = true, handleTouchmove(e));
          });
          $swiperWrapper.on('mouseup', function(e) {
            pressing && (pressing = false, handleTouchend(e));
          });
          $swiperWrapper.on('mouseleave', function(e) {
            pressing && (pressing = false, handleTouchend(e));
          });
          $swiperWrapper.on('click', function(e) {
            moved && (e.stopPropagation(), moved = false);
          });
        })();

        $root.on('touchmove', function(e) {
          if (e.cancelable & touching) {
            e.preventDefault();
          }
        });
      })();

      return {
        setOptions: setOptions,
        previous: function(){
          move('prev');
        },
        next: function(){
          move('next');
        },
        refresh: function() {
          calc(true, { animation: false });
        }
      };
    }
    $.fn.swiper = swiper;
  });
})();
var SOURCES = window.TEXT_VARIABLES.sources;
window.Lazyload.js(SOURCES.jquery, function() {
  $('.swiper-demo').swiper();
});
</script>

:ET